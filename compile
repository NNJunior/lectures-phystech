#!/usr/bin/env python3
r"""
Compiles a lecture from folder lectures/semN/SubjectName into a PDF.
This script is intended to be placed in the **root directory of the project**
(i.e. where the 'preamble' folder lives).

Usage: ./compile_lecture.py lectures/sem1/MathLog

The script copies:
  - the common preamble folder,
  - the global images folder (if present),
  - setting.tex and main.tex from lectures/semN/SubjectName,
  - preamble/main.tex → document.tex (verbatim, no rewriting).

It then runs pdflatex twice and places the resulting PDF into
../curly-waddle/pdf/semN/SubjectName.pdf (or a custom location
given with --result-dir).
"""

from __future__ import annotations

import argparse
import shutil
import subprocess
import sys
import tempfile
from pathlib import Path

# Optional chardet for better encoding detection
try:
    import chardet
    HAS_CHARDET = True
except ImportError:
    HAS_CHARDET = False

# ---------- ANSI color helpers ----------
class Color:
    """ANSI color codes for terminal output."""
    RED = '\033[91m'
    GREEN = '\033[92m'
    YELLOW = '\033[93m'
    BLUE = '\033[94m'
    MAGENTA = '\033[95m'
    CYAN = '\033[96m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'
    RESET = '\033[0m'

    @staticmethod
    def red(text: str) -> str:
        return f"{Color.RED}{text}{Color.RESET}"

    @staticmethod
    def green(text: str) -> str:
        return f"{Color.GREEN}{text}{Color.RESET}"

    @staticmethod
    def yellow(text: str) -> str:
        return f"{Color.YELLOW}{text}{Color.RESET}"

    @staticmethod
    def blue(text: str) -> str:
        return f"{Color.BLUE}{text}{Color.RESET}"

    @staticmethod
    def bold(text: str) -> str:
        return f"{Color.BOLD}{text}{Color.RESET}"


# ---------- Encoding utilities ----------
def detect_file_encoding(path: Path, default: str = "utf-8") -> str:
    """
    Detect the encoding of a file.

    First tries UTF-8, then cp1251, koi8-r, latin1.
    If chardet is installed, it is used for a smarter guess.

    Args:
        path: Path to the file.
        default: Fallback encoding if detection fails.

    Returns:
        Name of the detected encoding.
    """
    if HAS_CHARDET:
        try:
            with open(path, "rb") as f:
                raw = f.read()
            result = chardet.detect(raw)
            enc = result.get("encoding")
            if enc:
                return enc
        except Exception as e:
            print(
                Color.yellow(
                    f"Warning: chardet failed for {path.name}: {e}. "
                    "Falling back to manual encoding detection."
                ),
                file=sys.stderr,
            )

    for enc in ["utf-8", "cp1251", "koi8-r", "latin1"]:
        try:
            with open(path, "r", encoding=enc) as f:
                f.read()
            return enc
        except UnicodeDecodeError:
            continue
        except Exception as e:
            raise RuntimeError(f"Failed to read file {path} with encoding {enc}: {e}")

    return default


def read_file_with_encoding_detection(path: Path) -> tuple[list[str], str]:
    """
    Read a file, automatically detecting its encoding.

    Returns:
        A tuple: (list of lines, encoding used).

    Raises:
        FileNotFoundError: If the file does not exist.
        RuntimeError: If encoding detection or reading fails.
    """
    if not path.is_file():
        raise FileNotFoundError(f"File not found: {path}")

    enc = detect_file_encoding(path)
    try:
        with open(path, "r", encoding=enc) as f:
            lines = f.readlines()
        return lines, enc
    except Exception as e:
        raise RuntimeError(f"Could not read file {path} with encoding {enc}: {e}")


# ---------- Filesystem utilities ----------
def safe_copy_tree(src: Path, dst: Path, ignore_dangling_symlinks: bool = False) -> None:
    """Copy a directory tree with proper error handling."""
    try:
        shutil.copytree(src, dst, ignore_dangling_symlinks=ignore_dangling_symlinks)
    except FileExistsError:
        raise RuntimeError(f"Destination directory already exists: {dst}")
    except PermissionError as e:
        raise PermissionError(f"Permission denied copying {src} to {dst}: {e}")
    except OSError as e:
        raise RuntimeError(f"Failed to copy {src} to {dst}: {e}")


def safe_copy_file(src: Path, dst: Path) -> None:
    """Copy a single file with metadata and proper error handling."""
    try:
        shutil.copy2(src, dst)
    except FileNotFoundError:
        raise FileNotFoundError(f"Source file not found: {src}")
    except PermissionError as e:
        raise PermissionError(f"Permission denied copying {src} to {dst}: {e}")
    except OSError as e:
        raise RuntimeError(f"Failed to copy {src} to {dst}: {e}")


def prepare_compilation_directory(
    temp_dir: Path, project_root: Path, src_dir: Path
) -> None:
    r"""
    Populate a temporary directory with all files needed for compilation.

    Copies:
      - Entire preamble folder from project root
      - images folder from project root (if it exists)
      - setting.tex and main.tex from the lecture source directory
      - preamble/main.tex → document.tex (verbatim copy, no modifications)

    The template already contains \input{setting} and \input{main} which work
    because setting.tex and main.tex are in the same directory.
    """
    # 1. Copy preamble
    preamble_src = project_root / "preamble"
    if not preamble_src.is_dir():
        raise NotADirectoryError(f"Preamble folder not found: {preamble_src}")
    safe_copy_tree(preamble_src, temp_dir / "preamble")

    # 2. Copy images folder if it exists (optional)
    images_src = project_root / "images"
    if images_src.is_dir():
        safe_copy_tree(images_src, temp_dir / "images")
    else:
        print(
            Color.yellow("Warning: images folder not found, images may be missing."),
            file=sys.stderr,
        )

    # 3. Copy the lecture's specific TeX files
    setting_src = src_dir / "setting.tex"
    main_src = src_dir / "main.tex"
    if not setting_src.is_file():
        raise FileNotFoundError(f"Missing required file: {setting_src}")
    if not main_src.is_file():
        raise FileNotFoundError(f"Missing required file: {main_src}")

    safe_copy_file(setting_src, temp_dir / "setting.tex")
    safe_copy_file(main_src, temp_dir / "main.tex")

    # 4. Copy the template (preamble/main.tex) to document.tex verbatim
    template_path = temp_dir / "preamble" / "main.tex"
    if not template_path.is_file():
        raise FileNotFoundError(f"Template not found: {template_path}")

    # Detect encoding for informational message only
    _, template_encoding = read_file_with_encoding_detection(template_path)
    print(Color.blue(f"Template encoding: {template_encoding}"))

    # Copy the file as-is (preserves encoding, no rewriting)
    document_path = temp_dir / "document.tex"
    safe_copy_file(template_path, document_path)
    print(Color.blue("Template copied verbatim to document.tex"))


def compile_pdf(temp_dir: Path, pdflatex_cmd: str, runs: int = 2) -> Path:
    """
    Run pdflatex the specified number of times to generate a PDF.

    Returns:
        Path to the generated PDF.

    Raises:
        RuntimeError: If pdflatex is not found or compilation fails.
        FileNotFoundError: If PDF is not created after compilation.
    """
    pdflatex = shutil.which(pdflatex_cmd)
    if not pdflatex:
        raise RuntimeError(
            f"'{pdflatex_cmd}' not found in PATH. Please install LaTeX or specify a valid path."
        )

    for i in range(runs):
        try:
            result = subprocess.run(
                [pdflatex, "-interaction=nonstopmode", "document.tex"],
                cwd=temp_dir,
                capture_output=True,
                timeout=60,
            )
        except subprocess.TimeoutExpired:
            raise RuntimeError(f"pdflatex timed out after 60 seconds (run {i+1}/{runs})")
        except Exception as e:
            raise RuntimeError(f"Failed to execute pdflatex: {e}")

        if result.returncode != 0:
            sys.stderr.buffer.write(result.stderr)
            sys.stderr.buffer.write(result.stdout)
            raise subprocess.CalledProcessError(
                result.returncode,
                result.args,
                output=result.stdout,
                stderr=result.stderr,
            )

    pdf_path = temp_dir / "document.pdf"
    if not pdf_path.is_file():
        raise FileNotFoundError("PDF was not created after compilation")
    return pdf_path


def main() -> None:
    parser = argparse.ArgumentParser(
        description=Color.bold("Compile a lecture into PDF and place it in result/semN/"),
        formatter_class=argparse.RawDescriptionHelpFormatter,
    )
    parser.add_argument(
        "source_dir",
        help="Full relative path to the lecture folder from project root, e.g. 'lectures/sem1/MathLog'",
    )
    parser.add_argument(
        "--result-dir",
        dest="result_dir",
        default="../curly-waddle/pdf",
        help="Root folder where the result will be stored (default: ../curly-waddle/pdf). "
             "Inside it, semN/SubjectName.pdf is created.",
    )
    parser.add_argument(
        "--pdflatex",
        default="pdflatex",
        help="Path to the pdflatex executable (default: search in PATH)",
    )
    parser.add_argument(
        "--runs",
        type=int,
        default=2,
        help="Number of pdflatex runs (default: 2)",
    )
    parser.add_argument(
        "--keep-temp",
        action="store_true",
        help="Do not delete the temporary directory (useful for debugging)",
    )
    args = parser.parse_args()

    # ----- Determine project root (directory containing this script) -----
    project_root = Path(__file__).parent.resolve()
    print(Color.blue(f"Project root: {project_root}"))

    # ----- Construct full source path (user provides full relative path) -----
    src_dir = (project_root / args.source_dir).resolve()
    if not src_dir.is_dir():
        sys.exit(Color.red(f"Error: {src_dir} is not a directory or does not exist."))

    setting_path = src_dir / "setting.tex"
    main_path = src_dir / "main.tex"
    if not setting_path.is_file():
        sys.exit(Color.red(f"Error: {setting_path} is missing."))
    if not main_path.is_file():
        sys.exit(Color.red(f"Error: {main_path} is missing."))

    # Extract semester and subject name from the source path
    sem_dir = src_dir.parent.name
    subject_name = src_dir.name

    # ----- Prepare output directory -----
    result_root = Path(args.result_dir)
    # If result_dir is relative, interpret it relative to project root
    if not result_root.is_absolute():
        result_root = (project_root / result_root).resolve()
    target_dir = result_root / sem_dir
    try:
        target_dir.mkdir(parents=True, exist_ok=True)
    except Exception as e:
        sys.exit(Color.red(f"Error creating output directory {target_dir}: {e}"))
    target_pdf = target_dir / f"{subject_name}.pdf"

    # ----- Temporary directory and compilation -----
    try:
        with tempfile.TemporaryDirectory(prefix="compile_lecture_") as tmp:
            temp_dir = Path(tmp)
            try:
                prepare_compilation_directory(temp_dir, project_root, src_dir)
                pdf_path = compile_pdf(temp_dir, args.pdflatex, args.runs)
                safe_copy_file(pdf_path, target_pdf)
                print(Color.green(f"Done: {target_pdf}"))
            except Exception as e:
                print(Color.red(f"Compilation error: {e}"), file=sys.stderr)
                if args.keep_temp:
                    print(Color.yellow(f"Temporary files kept in {temp_dir}"), file=sys.stderr)
                sys.exit(1)

            if args.keep_temp:
                keep_path = Path.cwd() / f"temp_{sem_dir}_{subject_name}"
                try:
                    shutil.move(str(temp_dir), str(keep_path))
                    print(Color.yellow(f"Temporary files moved to {keep_path}"))
                except Exception as e:
                    print(Color.red(f"Failed to move temporary directory: {e}"), file=sys.stderr)
                    sys.exit(1)

    except KeyboardInterrupt:
        print(Color.yellow("\nInterrupted by user."), file=sys.stderr)
        sys.exit(130)
    except Exception as e:
        print(Color.red(f"Unexpected error: {e}"), file=sys.stderr)
        sys.exit(1)


if __name__ == "__main__":
    main()